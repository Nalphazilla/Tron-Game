<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tron Light Cycle Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            text-align: center;
            pointer-events: all;
        }
        
        #menu h1 {
            color: #00ffff;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .menu-section {
            margin-bottom: 30px;
        }
        
        .menu-section h2 {
            color: #00ffff;
            margin-bottom: 15px;
        }
        
        select, button {
            background: #000;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        select:hover, button:hover {
            background: #00ffff;
            color: #000;
        }
        
        #startButton {
            background: #00ff00;
            color: #000;
            border-color: #00ff00;
            font-size: 18px;
            padding: 15px 30px;
        }
        
        #startButton:hover {
            background: #00cc00;
            border-color: #00cc00;
        }
        
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: all;
        }
        
        #gameUI h2 {
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        #gameUI button {
            margin-right: 10px;
        }
        
        #playerColors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .player-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .player-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .player-circle:hover {
            transform: scale(1.1);
            border-color: #fff;
        }
        
        .player-circle.selected {
            border-color: #fff;
            box-shadow: 0 0 20px #fff;
        }
        
        #colorOptions {
            position: absolute;
            bottom: -120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            display: none;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            z-index: 1000;
        }
        
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .color-option:hover {
            transform: scale(1.2);
            border-color: #fff;
        }
        
        .hidden {
            display: none !important;
        }
        
        #invulnerabilityCountdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #00ffff;
            text-align: center;
            pointer-events: none;
            z-index: 200;
        }
        
        #invulnerabilityCountdown h2 {
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        #countdownTimer {
            color: #fff;
            font-size: 4em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="menu">
                <h1>TRON LIGHT CYCLE</h1>
                
                <div class="menu-section">
                    <h2>Game Mode</h2>
                    <select id="gameMode">
                        <option value="pvp">PvP</option>
                        <option value="ffa">4 Player</option>
                    </select>
                </div>
                
                <div class="menu-section">
                    <h2>Map</h2>
                    <select id="mapSelect">
                        <option value="The Grid">The Grid</option>
                        <option value="The Arena">The Arena</option>
                    </select>
                </div>
                
                <div class="menu-section">
                    <h2>Player Colors</h2>
                    <div id="playerColors">
                        <div class="player-container">
                            <div>P1</div>
                            <div class="player-circle" data-player="p1" style="background-color: #ff0000;"></div>
                        </div>
                        <div class="player-container">
                            <div>P2</div>
                            <div class="player-circle" data-player="p2" style="background-color: #00ff00;"></div>
                        </div>
                        <div class="player-container">
                            <div>P3</div>
                            <div class="player-circle" data-player="p3" style="background-color: #0000ff;"></div>
                        </div>
                        <div class="player-container">
                            <div>P4</div>
                            <div class="player-circle" data-player="p4" style="background-color: #ffff00;"></div>
                        </div>
                    </div>
                    
                    <div id="colorOptions">
                        <div class="color-option" data-color="#ff0000" style="background-color: #ff0000;"></div>
                        <div class="color-option" data-color="#00ff00" style="background-color: #00ff00;"></div>
                        <div class="color-option" data-color="#0000ff" style="background-color: #0000ff;"></div>
                        <div class="color-option" data-color="#ffff00" style="background-color: #ffff00;"></div>
                        <div class="color-option" data-color="#ff8000" style="background-color: #ff8000;"></div>
                        <div class="color-option" data-color="#ff0080" style="background-color: #ff0080;"></div>
                        <div class="color-option" data-color="#8000ff" style="background-color: #8000ff;"></div>
                        <div class="color-option" data-color="#00ffff" style="background-color: #00ffff;"></div>
                        <div class="color-option" data-color="#ffffff" style="background-color: #ffffff;"></div>
                        <div class="color-option" data-color="#0080ff" style="background-color: #0080ff;"></div>
                        <div class="color-option" data-color="#80ff00" style="background-color: #80ff00;"></div>
                        <div class="color-option" data-color="#008080" style="background-color: #008080;"></div>
                    </div>
                </div>
                
                <button id="startButton">START GAME</button>
            </div>
            
            <div id="gameUI" class="hidden">
                <h2>Game Controls</h2>
                <button id="backToMenu">Back to Menu</button>
                <button id="endGame">End Game</button>
            </div>
            
            <div id="invulnerabilityCountdown" class="hidden">
                <h2>Invulnerability</h2>
                <div id="countdownTimer">3</div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/UnrealBloomPass.js';

        // Game state
        let gameState = 'MENU';
        let players = [];
        let isAlive = true;
        let currentMap = 'The Grid';
        
        // Three.js variables
        let scene, camera, renderer, composer;
        let gameSize = 100;
        let mapObjects = [];
        
        // UI elements
        const menu = document.getElementById('menu');
        const gameUI = document.getElementById('gameUI');
        const startButton = document.getElementById('startButton');
        const backToMenuButton = document.getElementById('backToMenu');
        const endGameButton = document.getElementById('endGame');
        const gameModeSelect = document.getElementById('gameMode');
        const mapSelect = document.getElementById('mapSelect');
        const invulnerabilityCountdown = document.getElementById('invulnerabilityCountdown');
        const countdownTimer = document.getElementById('countdownTimer');
        
        // Player colors
        let playerColors = {
            p1: '#ff0000',
            p2: '#00ff00',
            p3: '#0000ff',
            p4: '#ffff00'
        };
        
        let selectedPlayer = null;
        
        // Initialize the game
        function init() {
            // Set up Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Set up post-processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.0,  // strength
                0.5,  // radius
                0.85  // threshold
            );
            composer.addPass(bloomPass);
            
            // Set up lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);
            
            // Set up event listeners
            startButton.addEventListener('click', startGame);
            backToMenuButton.addEventListener('click', backToMenu);
            endGameButton.addEventListener('click', endGame);
            gameModeSelect.addEventListener('change', updatePlayerVisibility);
            mapSelect.addEventListener('change', (e) => {
                currentMap = e.target.value;
            });
            
            // Set up player color selection
            setupPlayerColorSelection();
            
            // Initial player visibility update
            updatePlayerVisibility();
            
            // Start render loop
            animate();
        }
        
        function setupPlayerColorSelection() {
            const playerCircles = document.querySelectorAll('.player-circle');
            const colorOptions = document.querySelectorAll('.color-option');
            
            playerCircles.forEach(circle => {
                circle.addEventListener('click', () => {
                    selectPlayer(circle.dataset.player);
                });
            });
            
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    selectColor(option.dataset.color);
                });
            });
        }
        
        function selectPlayer(player) {
            selectedPlayer = player;
            
            // Update visual selection
            document.querySelectorAll('.player-circle').forEach(circle => {
                circle.classList.remove('selected');
            });
            document.querySelector(`[data-player="${player}"]`).classList.add('selected');
            
            // Show color options
            document.getElementById('colorOptions').style.display = 'grid';
        }
        
        function selectColor(color) {
            if (selectedPlayer) {
                playerColors[selectedPlayer] = color;
                document.querySelector(`[data-player="${selectedPlayer}"]`).style.backgroundColor = color;
                
                // Hide color options and remove selection
                document.getElementById('colorOptions').style.display = 'none';
                document.querySelectorAll('.player-circle').forEach(circle => {
                    circle.classList.remove('selected');
                });
                selectedPlayer = null;
            }
        }
        
        function updatePlayerVisibility() {
            const gameMode = gameModeSelect.value;
            const playerContainers = document.querySelectorAll('.player-container');
            
            playerContainers.forEach((container, index) => {
                if (gameMode === 'pvp' && index < 2) {
                    container.style.display = 'flex';
                } else if (gameMode === 'ffa') {
                    container.style.display = 'flex';
                } else {
                    container.style.display = 'none';
                }
            });
        }
        
        function startGame() {
            gameState = 'PLAYING';
            menu.classList.add('hidden');
            gameUI.classList.remove('hidden');
            
            // Load map and start game
            loadMap(currentMap);
            resetGame(false);
            
            // Show invulnerability countdown
            invulnerabilityCountdown.classList.remove('hidden');
            startInvulnerabilityCountdown();
        }
        
        function startInvulnerabilityCountdown() {
            let countdown = 3;
            countdownTimer.textContent = countdown;
            
            const countdownInterval = setInterval(() => {
                countdown--;
                countdownTimer.textContent = countdown;
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    invulnerabilityCountdown.classList.add('hidden');
                }
            }, 1000);
        }
        
        function backToMenu() {
            gameState = 'MENU';
            gameUI.classList.add('hidden');
            menu.classList.remove('hidden');
            invulnerabilityCountdown.classList.add('hidden');
            cleanupGame();
        }
        
        function endGame() {
            gameState = 'MENU';
            gameUI.classList.add('hidden');
            menu.classList.remove('hidden');
            invulnerabilityCountdown.classList.add('hidden');
            cleanupGame();
        }
        
        function loadMap(mapName) {
            // Clear existing map objects
            mapObjects.forEach(obj => scene.remove(obj));
            mapObjects = [];
            
            if (mapName === 'The Arena') {
                createArenaObstacles();
            }
        }
        
        function createArenaObstacles() {
            const obstacleMat = new THREE.MeshStandardMaterial({
                color: 0x666688,
                metalness: 0.3,
                roughness: 0.7,
                emissive: 0x444466,
                emissiveIntensity: 0.8
            });
            
            // Central block
            const centerBlock = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 20),
                obstacleMat
            );
            centerBlock.position.set(0, 4, 0);
            centerBlock.userData.isRamp = false;
            scene.add(centerBlock);
            mapObjects.push(centerBlock);
            
            // Add bright cyan outline to deadly obstacles
            const outline = new THREE.LineSegments(
                new THREE.EdgesGeometry(centerBlock.geometry),
                new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 })
            );
            outline.position.copy(centerBlock.position);
            scene.add(outline);
            mapObjects.push(outline);
            
            // Ramps
            const rampGeometry = new THREE.BoxGeometry(8, 2, 8);
            const rampPositions = [
                { x: 15, y: 1, z: 0 },
                { x: -15, y: 1, z: 0 },
                { x: 0, y: 1, z: 15 },
                { x: 0, y: 1, z: -15 }
            ];
            
            rampPositions.forEach(pos => {
                const ramp = new THREE.Mesh(rampGeometry, obstacleMat);
                ramp.position.set(pos.x, pos.y, pos.z);
                ramp.userData.isRamp = true;
                scene.add(ramp);
                mapObjects.push(ramp);
                
                // Add green outline to ramps
                const rampOutline = new THREE.LineSegments(
                    new THREE.EdgesGeometry(ramp.geometry),
                    new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 })
                );
                rampOutline.position.copy(ramp.position);
                scene.add(rampOutline);
                mapObjects.push(rampOutline);
            });
        }
        
        function cleanupGame() {
            players.forEach(player => {
                if (player.mesh) {
                    scene.remove(player.mesh);
                }
                if (player.trail) {
                    scene.remove(player.trail);
                }
            });
            players = [];
            isAlive = true;
        }
        
        function resetGame(showMenu = true) {
            if (showMenu) {
                gameState = 'MENU';
                gameUI.classList.add('hidden');
                menu.classList.remove('hidden');
            }
            
            cleanupGame();
            
            const gameMode = gameModeSelect.value;
            const numPlayers = gameMode === 'pvp' ? 2 : 4;
            
            for (let i = 0; i < numPlayers; i++) {
                const player = new Player(i, numPlayers);
                players.push(player);
                scene.add(player.mesh);
            }
            
            // Position camera
            updateCamera();
        }
        
        function updateCamera() {
            if (players.length > 0 && players[0].isAlive) {
                const player = players[0];
                const offset = new THREE.Vector3(0, 15, 20);
                camera.position.copy(player.mesh.position).add(offset);
                camera.lookAt(player.mesh.position);
            }
        }
        
        class Player {
            constructor(index, totalPlayers) {
                this.index = index;
                this.isAlive = true;
                this.speed = 0.5;
                this.turnSpeed = 0.05;
                this.turnDirection = 0;
                this.targetTilt = 0;
                this.currentTilt = 0;
                this.invulnerable = false;
                this.invulnerabilityTimer = 0;
                
                // Calculate spawn position
                const angle = (index / totalPlayers) * Math.PI * 2;
                const offset = gameSize / 2.2;
                this.startPosition = new THREE.Vector3(
                    Math.cos(angle) * offset,
                    1,
                    Math.sin(angle) * offset
                );
                
                this.mesh = this.createLightCycleModel();
                this.mesh.position.copy(this.startPosition);
                this.mesh.rotation.y = angle + Math.PI;
                
                this.trail = null;
                this.reset();
            }
            
            createLightCycleModel() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    emissiveIntensity: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 8);
                const wheelMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    emissiveIntensity: 0.5
                });
                
                const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                frontWheel.rotation.z = Math.PI / 2;
                frontWheel.position.set(0, -0.5, 1.5);
                group.add(frontWheel);
                
                const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                backWheel.rotation.z = Math.PI / 2;
                backWheel.position.set(0, -0.5, -1.5);
                group.add(backWheel);
                
                return group;
            }
            
            reset() {
                this.isAlive = true;
                this.mesh.position.copy(this.startPosition);
                this.mesh.rotation.y = (this.index / players.length) * Math.PI * 2 + Math.PI;
                this.turnDirection = 0;
                this.targetTilt = 0;
                this.currentTilt = 0;
                this.invulnerable = true;
                this.invulnerabilityTimer = 180; // 3 seconds at 60fps
                
                if (this.trail) {
                    scene.remove(this.trail);
                    this.trail = null;
                }
            }
            
            update() {
                if (!this.isAlive) return;
                
                // Handle invulnerability
                if (this.invulnerable) {
                    this.invulnerabilityTimer--;
                    
                    // Flashing effect during invulnerability
                    const flashIntensity = Math.sin(this.invulnerabilityTimer * 0.3) * 0.5 + 0.5;
                    this.mesh.children.forEach(child => {
                        if (child.material && child.material.emissiveIntensity !== undefined) {
                            child.material.emissiveIntensity = flashIntensity;
                        }
                    });
                    
                    if (this.invulnerabilityTimer <= 0) {
                        this.invulnerable = false;
                        this.createTrail();
                    }
                }
                
                // Handle input
                if (this.index === 0) { // Player 1 controls
                    if (keys['KeyA'] || keys['ArrowLeft']) {
                        this.turnDirection = -1;
                    } else if (keys['KeyD'] || keys['ArrowRight']) {
                        this.turnDirection = 1;
                    } else {
                        this.turnDirection = 0;
                    }
                }
                
                // Update tilt
                this.targetTilt = this.turnDirection * Math.PI / 6;
                this.currentTilt += (this.targetTilt - this.currentTilt) * 0.1;
                this.mesh.rotation.z = this.currentTilt;
                
                // Move forward
                this.mesh.translateZ(-this.speed);
                
                // Check boundaries
                if (Math.abs(this.mesh.position.x) > gameSize / 2 || Math.abs(this.mesh.position.z) > gameSize / 2) {
                    this.die();
                    return;
                }
                
                // Check collisions
                this.checkCollisions();
                
                // Update trail position
                if (this.trail && !this.invulnerable) {
                    this.trail.position.copy(this.mesh.position);
                }
            }
            
            createTrail() {
                if (this.trail) return;
                
                const trailGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const trailMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    transparent: true,
                    opacity: 0.8,
                    emissive: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    emissiveIntensity: 0.3
                });
                
                this.trail = new THREE.Mesh(trailGeometry, trailMaterial);
                this.trail.position.copy(this.mesh.position);
                scene.add(this.trail);
            }
            
            checkCollisions() {
                if (this.invulnerable) return;
                
                // Check collision with other players' trails
                players.forEach(otherPlayer => {
                    if (otherPlayer !== this && otherPlayer.trail) {
                        const playerBox = new THREE.Box3().setFromObject(this.mesh);
                        const trailBox = new THREE.Box3().setFromObject(otherPlayer.trail);
                        
                        if (playerBox.intersectsBox(trailBox)) {
                            this.die();
                            return;
                        }
                    }
                });
                
                // Check collision with map objects (excluding ramps)
                const deadlyObjects = mapObjects.filter(obj => !obj.userData.isRamp);
                deadlyObjects.forEach(obj => {
                    const playerBox = new THREE.Box3().setFromObject(this.mesh);
                    const objBox = new THREE.Box3().setFromObject(obj);
                    
                    if (playerBox.intersectsBox(objBox)) {
                        this.die();
                        return;
                    }
                });
            }
            
            die() {
                this.isAlive = false;
                this.createDeathAnnouncement();
                
                // Check if game is over
                const alivePlayers = players.filter(p => p.isAlive);
                if (alivePlayers.length <= 1) {
                    if (alivePlayers.length === 1) {
                        // Winner
                        setTimeout(() => {
                            alert(`Player ${alivePlayers[0].index + 1} wins!`);
                            resetGame();
                        }, 1000);
                    } else {
                        // Tie
                        setTimeout(() => {
                            alert("It's a tie!");
                            resetGame();
                        }, 1000);
                    }
                    invulnerabilityCountdown.classList.add('hidden');
                }
            }
            
            createDeathAnnouncement() {
                const geometry = new THREE.SphereGeometry(5, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    transparent: true,
                    opacity: 0.8,
                    emissive: new THREE.Color(playerColors[`p${this.index + 1}`]),
                    emissiveIntensity: 0.3
                });
                
                const explosion = new THREE.Mesh(geometry, material);
                explosion.position.copy(this.mesh.position);
                scene.add(explosion);
                
                // Animate explosion
                let scale = 1;
                const animate = () => {
                    scale += 0.1;
                    explosion.scale.setScalar(scale);
                    explosion.material.opacity -= 0.02;
                    
                    if (explosion.material.opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(explosion);
                    }
                };
                animate();
            }
        }
        
        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameState === 'PLAYING') {
                players.forEach(player => player.update());
                updateCamera();
            }
            
            composer.render();
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
